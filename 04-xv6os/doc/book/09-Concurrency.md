# Chapter 9 -- Concurrency revisited

同時獲得良好的並行性能、並发情況下的正確性和可理解的代碼是內核設計中的一大挑戰。直接使用鎖是實現正確性的最佳途徑，但並不總是可能的。本章重點介紹了xv6被迫以涉及的方式使用鎖的例子，以及xv6使用類似鎖的技術但不使用鎖的例子。

## 9.1 Locking patterns

緩存項目通常是鎖定的一個挑戰。例如，文件系統的塊緩存(kernel/bio.c:26)存儲了多達NBUF磁盤塊的副本。一個給定的磁盤塊在緩存中最多只有一個副本，這一點非常重要；否則，不同的進程可能會對本應是同一個塊的不同副本進行沖突的修改。每一個緩存塊都被存儲在一個buf結構中(kernel/buf.h:1)。

buf結構有一個鎖字段，它有助於確保每次只有一個進程使用一個給定的磁盤塊。然而，這個鎖是不夠的：如果一個塊根本不存在於緩存中，而兩個進程想同時使用它怎麽辦？沒有struct buf（因為塊還沒有被緩存），因此沒有什麽可鎖定的。Xv6處理這種情況的方法是將緩存塊的身份集關聯一個額外的鎖（bcache.lock）。需要檢查某個塊是否被緩存的代碼（例如，bget(kernel/bio.c:59)），或者改變緩存塊的集合，必須持有bcache.lock；當該代碼找到它所需要的塊和struct buf之後，它可以釋放bcache.lock，只鎖定特定的塊。這是一種常見的模式：一組項的一個鎖，加上每個項的一個鎖。

通常情況下，獲取鎖的同一個函數會釋放它。但更精確的看法是，在一個序列開始時獲取一個鎖，這個序列必須顯得原子化，當這個序列結束時釋放。如果序列的開始和結束在不同的函數中，或者不同的線程中，或者在不同的CPU上，那麽鎖的獲取和釋放也必須是一樣的。鎖的功能是強制其他使用等待，而不是將一段數據釘在某個代理上。一個例子是yield中的acquisition(kernel/proc.c:515)，它是在調度線程中釋放的，而不是在獲取過程中釋放的。另一個例子是ilock(kernel/fs.c:289)中的acquiresleep；這段代碼經常在讀取磁盤時睡覺；它可能會在不同的CPU上醒來，這意味著鎖可能會在不同的CPU上被獲取和釋放。

釋放一個被嵌入鎖保護的對象是一件微妙的事情，因為擁有鎖並不足以保證釋放會正確。當有其他線程在獲取中等待使用對象時，問題就會出現；釋放對象隱含地釋放了嵌入的鎖，這將導致等待的線程发生故障。一個解決方案是跟蹤對象存在多少個引用，因此只有當最後一個引用消失時才會釋放對象。參見pipeclose(kernel/pipe.c:59)的例子；pi->readopen和pi->writeopen跟蹤管道是否有文件描述符引用它。

## 9.2 Lock-like patterns

在許多地方，xv6使用引用計數或標志作為一種軟鎖，以表明一個對象已被分配，不應該被釋放或重新使用。進程的p->狀態以這種方式起作用，文件、inode和buf結構中的引用計數也是如此。雖然在每種情況下，鎖都會保護標志或引用計數，但正是後者防止了對象被過早釋放。

文件系統將inode結構的引用計數作為一種共享鎖，可以由多個進程持有，以避免代碼使用普通鎖時出現死鎖。例如，namex(kernel/fs.c:626)中的循環依次鎖住每個路徑名組件命名的目錄。然而，namex必須在循環結束時釋放每一個鎖，因為如果它持有多個鎖，那麽如果路徑名中包含一個點(例如，a/./b)，它可能會與自己发生死鎖。它也可能因為涉及目錄和...的並发查找而死鎖。

正如第8章所解釋的那樣，解決方案是讓循環將目錄inode帶入下一次叠代，並增加其引用計數，但不鎖定。

有些數據項在不同的時候受到不同機制的保護，有時可能會被xv6代碼的結構隱式保護，而不是通過顯式鎖來防止並发訪問。例如，當一個物理頁是空閑的時候，它被kmem.lock（kernel/kalloc.c:24）保護。如果頁面被分配為管道(kernel/pipe.c:23)，它將受到不同的鎖(嵌入式pi->鎖)保護。如果該頁被重新分配給一個新進程的用戶內存，它就不會受到鎖的保護。相反，分配器不會將該頁交給任何其他進程（直到它被釋放），這一事實保護了它不被並发訪問。一個新進程的內存的所有權是很複雜的：首先父進程在fork中分配和操作它，然後子進程使用它，（在子進程退出後）父進程再次擁有內存並將其傳遞給kfree。這里有兩個教訓：一個數據對象在其生命周期中的不同階段可以用不同的方式保護其免受並发，保護的形式可以是隱式結構而不是顯式鎖。

最後一個類似鎖的例子是在調用mycpu()(kernel/proc.c:68)時需要禁用中斷。禁用中斷會導致調用代碼對定時器中斷是原子性的，可能會強制上下文切換，從而將進程移到不同的CPU上。

## 9.3 No locks at all

有幾個地方，xv6在完全沒有鎖的情況下共享可變數據。一個是在spinlocks的實現中，盡管人們可以把RISC-V原子指令看作是依靠硬件實現的鎖。另一個是main.c(kernel/main.c:7)中的start變量，用於防止其他CPU運行，直到CPU zero完成xv6的初始化；volatile確保編譯器真正產生加載和存儲指令。第三個是在proc.c（kernel/proc.c:398）（kernel/proc.c:306）中對p->parent的一些使用，適當的鎖定可能會死鎖，但似乎很明顯，沒有其他進程可以同時修改p->parent。

第四個例子是p->killed，它是在持有p->鎖的情況下設置的(kernel/proc.c:611)，但是在沒有持有鎖的情況下檢查(kernel/trap.c:56)。

Xv6中包含這樣的情況：一個CPU或線程寫一些數據，另一個CPU或線程讀數據，但沒有專門的鎖來保護這些數據。例如，在fork中，父線寫入子線程的用戶內存頁，子線程（不同的線程，也許在不同的CPU上）讀取這些頁；沒有鎖明確地保護這些頁。嚴格來說，這並不是一個鎖的問題，因為子程序在父程序寫完後才開始執行。這是一個潛在的內存排序問題（見第6章），因為沒有內存屏障，就沒有理由期望一個CPU看到另一個CPU的寫入。然而，由於父代釋放鎖，而子代在啟動時獲取鎖，所以獲取和釋放中的內存屏障確保子代的CPU看到父代的寫。

## 9.4 Parallelism

鎖定主要是為了正確性而抑制並行性。因為性能也很重要，所以內核設計者經常要考慮如何使用鎖的方式來實現正確性和良好的並行性。雖然xv6並沒有系統性地設計高性能，但還是值得考慮哪些xv6操作可以並行執行，哪些操作可能在鎖上发生沖突。

xv6中的管道是一個相當好的並行性的例子。每個管道都有自己的鎖，因此不同的進程可以在不同的CPU上並行讀寫不同的管道。但是，對於一個給定的管道，寫入者和讀取者必須等待對方釋放鎖，他們不能同時讀/寫同一個管道。還有一種情況是，從空管子讀（或向滿管子寫）必須阻塞，但這不是由於鎖方案造成的。

上下文切換是一個更複雜的例子。兩個內核線程，每個線程都在自己的CPU上執行，可以同時調用yield、sched和swtch，這些調用將並行執行。

線程各自持有一個鎖，但它們是不同的鎖，所以它們不必等待對方。但是一旦進入調度器，兩個CPU可能會在鎖上发生沖突，同時在進程表中搜索一個是RUNNABLE的。也就是說，xv6在上下文切換過程中很可能從多個CPU中獲得性能上的好處，但可能沒有那麽多。

另一個例子是在不同的CPU上從不同的進程並发調用fork。這些調用可能需要互相等待pid_lock和kmem.lock，以及在進程表中搜索unused進程所需的每進程鎖。另一方面，兩個分叉進程可以完全並行地複製用戶內存頁和格式化頁表頁。

上述每個例子中的鎖方案在某些情況下犧牲了並行性能。在每種情況下，都可以使用更複雜的設計來獲得更多的並行性。是否值得取決於細節：相關操作被調用的頻率、代碼在持有爭用鎖的情況下所花費的時間、同時可能有多少CPU在運行沖突的操作、代碼的其他部分是否是更多的限制性瓶頸。很難猜測一個給定的鎖方案是否會導致性能問題，或者一個新的設計是否有明顯的改進，所以往往需要對現實的工作負載進行測量。

## 9.5 Exercises

1- 修改xv6的管道實現，允許對同一管道的讀寫在不同內核上並行進行。

2- 修改xv6的調度器()，以減少不同內核同時尋找可運行進程時的鎖爭用。

3- 取消xv6的fork()中的一些序列化。
