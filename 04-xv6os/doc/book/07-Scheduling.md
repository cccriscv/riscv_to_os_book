# Chapter 7 -- Scheduling

任何操作系統運行的進程數量都可能超過計算機的CPU數量，因此需要制定一個計劃，在各進程之間分時共享CPU。理想情況下，這種共享對用戶進程是透明的。一種常見的方法是通過將進程覆用到硬件CPU上，給每個進程提供它有自己的虛擬CPU的假象。本章解釋xv6如何實現這種覆用。

## 7.1 Multiplexing

xv6通過在兩種情況下將每個CPU從一個進程切換到另一個進程，從而實現覆用。首先，xv6的睡眠和喚醒機制在進程等待設備或管道I/O完成時，或等待子進程退出時，或在睡眠系統調用中等待時，會進行切換。其次，xv6會周期性地強制切換，以應對長時間不睡覺的計算進程。這種多路覆用造成了每個進程都有自己的CPU的假象，就像xv6使用內存分配器和硬件頁表造成每個進程都有自己的內存的假象一樣。

實現多路覆用帶來了一些挑戰。首先，如何從一個進程切換到另一個進程？雖然上下文切換的想法很簡單，但實現起來卻是xv6中最不透明的一些代碼。第二，如何以對用戶進程透明的方式強制切換？xv6采用標準的技術，用定時器中斷來驅動上下文切換。第三，許多CPU可能會在進程間並发切換，為了避免競賽，需要制定鎖定計劃。第四，當進程退出時，必須釋放進程的內存和其他資源，但它自己不能做到這一切，因為（例如）它不能在還在使用內核棧時釋放自己的內核棧。第五，多核機的每個內核必須記住它正在執行的進程，這樣系統調用就會影響正確的進程的內核狀態。最後，睡眠和喚醒允許一個進程放棄CPU和睡眠等待事件，並允許另一個進程喚醒第一個進程。需要注意避免競賽，導致喚醒通知的丟失。Xv6試圖盡可能簡單地解決這些問題，但盡管如此，產生的代碼還是很棘手的

![](../img/Figure7.1.png)

## 7.2 Code: Context switching

圖7.1概述了從一個用戶進程切換到另一個用戶進程的步驟：用戶內核轉換（系統調用或中斷）到舊進程的內核線程，上下文切換到當前CPU的調度器線程，上下文切換到新進程的內核線程，陷阱返回到用戶級進程。xv6調度器每個CPU有一個專門的線程（保存的寄存器和堆棧），因為調度器在舊進程的內核堆棧上執行是不安全的：其他一些核心可能會喚醒進程並運行它，而在兩個不同的核心上使用相同的堆棧將是一場災難。在這一節中，我們將研究內核線程和調度器線程之間的切換機制。

從一個線程切換到另一個線程涉及到保存舊線程的CPU寄存器，並恢復新線程之前保存的寄存器；保存和恢復堆棧指針和程序計數器意味著CPU將切換堆棧，切換它正在執行的代碼。

函數swtch執行內核線程切換的保存和恢復，swtch並不直接知道線程的情況，它只是保存和恢復寄存器集，稱為contexts。當一個進程要放棄CPU的時候，該進程的內核線程會調用swtch保存自己的上下文，並返回調度器上下文。每個上下文都包含在一個struct context（kernel/proc.h:2）中，它本身包含在進程的struct proc或CPU的struct cpu中。Swtch需要兩個參數：struct context *old和struct context *new。它將當前寄存器保存在old中，從new中加載寄存器，然後返回。

讓我們跟隨一個進程通過swtch進入調度器。我們在第4章看到，在中斷結束時，有一種可能是usertrap調用yield。yield又調用sched，sched調用swtch將當前上下文保存在p->context中，並切換到之前保存在cpu->scheduler中的調度器上下文（kernel/proc.c:509）。

Swtch(kernel/swtch.S:3)只保存調用者保存的寄存器，調用者保存的寄存器由調用的C代碼保存在堆棧上（如果需要的話）。Swtch知道結構上下文中每個寄存器字段的偏移量。它不保存程序計數器。相反，swtch保存了ra寄存器，它保存了swtch被調用的返回地址。現在，swtch從新的上下文中恢復寄存器，新的上下文中保存著前一次swtch所保存的寄存器值。當swtch返回時，它返回到被恢復的ra寄存器所指向的指令，也就是新線程之前調用swtch的指令。此外，它還會在新線程的棧上返回。

在我們的例子中，sched調用swtch切換到cpu->scheduler，即每CPU調度器上下文。這個上下文已經被調度器調用swtch（kernel/proc.c:475）保存了下來。當我們一直追蹤的swtch返回時，它不是返回到sched而是返回到調度器，它的棧指針指向當前CPU的調度器棧。

## 7.3 Code: Scheduling

上一節研究了swtch的低級細節，現在我們把swtch作為一個給定的條件，研究從一個進程的內核線程通過調度器切換到另一個進程。調度器以每個CPU一個特殊線程的形式存在，每個線程都運行調度器函數。

這個函數負責選擇下一步運行哪個進程。一個想要放棄CPU的進程必須獲得自己的進程鎖p->lock，釋放它所持有的其他鎖，更新自己的狀態（p->state），然後調用sched。Yield (kernel/proc.c:515)遵循這個慣例，就像我們稍後要研究的sleep和exit一樣。Sched對這些條件進行雙重檢查(kernel/proc.c:499-504)，然後對這些條件進行暗示：因為鎖被持有，所以中斷應該被禁止。最後，sched調用swtch保存p->context中的當前上下文，並在cpu->scheduler中切換到調度器上下文。swtch在調度器的堆棧上返回，就像調度器的swtch已經返回一樣 調度器繼續for循環，找到一個要運行的進程，切換到它，然後循環重覆。

我們剛剛看到xv6在調用swtch的過程中持有p->lock：swtch的調用者必須已經持有鎖，而鎖的控制權則傳遞給切換到的代碼。這種約定對於鎖來說是不尋常的，通常獲得鎖的線程也要負責釋放鎖，這樣更容易推理出正確性。對於上下文切換來說，有必要打破這個約定，因為p->lock保護了進程的狀態和上下文字段上的不變量，而這些不變量在swtch中執行時是不真實的。如果p->lock在swtch期間不被保持，可能會出現問題的一個例子：在yield將其狀態設置為RUNNABLE之後，但在swtch使其停止使用自己的內核棧之前，不同的CPU可能會決定運行這個進程。結果就是兩個CPU運行在同一個棧上，這是不可能的。

一個內核線程總是在sched中放棄它的CPU，並且總是切換到調度器的同一個位置，而調度器（幾乎）總是切換到之前調用sched的某個內核線程。因此，如果把xv6切換線程的行號打印出來，就會觀察到下面的簡單模式。(kernel/proc.c:475)，(kernel/proc.c:509)，(kernel/proc.c:475)，(kernel/proc.c:509)，等等。這種发生在兩個線程之間的風格化切換的程序有時被稱為coroutine；在這個例子中，sched和調度器是彼此的聯合程序。

有一種情況是，調度器對swtch的調用最終沒有在sched中完成。當一個新進程第一次被調度時，它開始於forkret(kernel/proc.c:527)。Forkret的存在是為了釋放p->鎖；否則，新進程可能從usertrapret開始。

調度器(kernel/proc.c:457)運行一個簡單的循環：找到一個要運行的進程，運行它直到它屈服，重覆。調度器在進程表上循環，尋找一個可運行的進程，一個有p->state == RUNNABLE的進程。一旦找到一個進程，它就會設置每個CPU當前進程變量c->proc，將該進程標記為RUNNING，然後調用swtch開始運行它(kernel/proc.c:470-475)。

思考調度代碼結構的一種方法是，它強制執行一組關於每個進程的不變性，並且每當這些不變性不為真時，就會持有p->lock。一個不變性是，如果一個進程在RUNNING，定時器中斷的產率必須能夠安全地從進程中切換開來；這意味著CPU寄存器必須持有進程的寄存器值（即swtch沒有把它們移到上下文中），c->proc必須引用進程。另一個不變性是，如果一個進程是RUNNABLE的，那麽對於一個空閑的CPU的調度器來說，運行它必須是安全的；這意味著p->context必須持有進程的寄存器（即它們實際上並不在真實的寄存器中），沒有CPU在進程的內核堆棧上執行，沒有CPU的c->proc引用進程。請注意，當p->lock被持有時，這些屬性往往不是真的。

保持上述不變性是xv6經常在一個線程中獲取p->lock，而在另一個線程中釋放它的原因，例如在yield中獲取，在調度器中釋放。一旦yield開始修改一個正在運行的進程的狀態，使其成為RUNNABLE，鎖必須一直保持，直到不變式被恢復：最早正確的釋放點是在調度器（運行在自己的堆棧上）清除c->proc之後。同樣，一旦調度器開始將一個RUNNABLE進程轉換為RUNNING進程，在內核線程完全運行之前（例如在yield中的swtch之後），鎖不能被釋放。

p->lock也保護其他的東西：退出和等待之間的相互作用，避免丟失喚醒的機制（見7.5節），以及避免進程退出和其他進程讀寫其狀態之間的競賽（例如，退出系統調用查看p->pid並設置p->killed (kernel/proc.c:611)）。也許值得思考的是，是否可以將p->lock的不同功能拆分開來，這樣既清晰，也可能是為了性能。

## 7.4 Code: mycpu and myproc

Xv6經常需要一個指向當前進程的proc結構的指針。在單核處理器上，可以有一個全局變量指向當前的proc。這在多核機器上是行不通的，因為每個核都執行不同的進程。解決這個問題的方法是利用每個核都有自己的一組寄存器的事實；我們可以使用其中的一個寄存器來幫助查找每個核的信息。

Xv6為每個CPU維護了一個結構cpu(kernel/proc.h:22)，它記錄了當前在該CPU上運行的進程(如果有的話)，為CPU的調度線程保存的寄存器，以及管理中斷禁用所需的嵌套自旋鎖的計數。函數mycpu(kernel/proc.c:60)返回一個指向當前CPU的結構cpu的指針。RISC-V對其CPU進行了編號，給每個CPU一個hartid。Xv6確保每個CPU的hartid在內核中存儲在該CPU的tp寄存器中。這使得mycpu可以使用tp來索引cpu結構的數組來找到正確的cpu。

確保CPU的tp始終保持CPU的hartid是有一點難度的。mstart在CPU啟動序列的早期設置tp寄存器，當時還處於機器模式(kernel/start.c:46)。最後，當從用戶空間進入內核時，uservec會恢復保存的tp(kernel/trampoline.S:70)。

編譯器保證永遠不使用tp寄存器。如果RISC-V允許xv6直接讀取當前的hartid會更方便，但這只允許在機器模式下，不允許在主管模式下使用。

cpuid和mycpu的返回值是很脆弱的：如果定時器中斷，導致線程屈服，然後轉移到不同的CPU上，之前返回的值將不再正確。為了避免這個問題，xv6要求調用者禁用中斷，只有在使用完返回的結構cpu後才啟用。

函數myproc(kernel/proc.c:68)返回當前CPU上運行的進程的struct proc指針，myproc禁用中斷，調用mycpu，從struct cpu中獲取當前進程指針(c->proc)，然後啟用中斷。即使啟用了中斷，myproc的返回值也可以安全使用：如果定時器中斷將調用進程移到了不同的CPU上，它的proc結構指針將保持不變。

## 7.5 Sleep and wakeup

調度和鎖有助於隱藏一個進程與另一個進程的存在，但到目前為止，我們還沒有任何抽象的方法來幫助進程有意地進行交互。人們发明了許多機制來解決這個問題。Xv6使用了一種叫做睡眠和喚醒的機制，它允許一個進程睡覺等待事件，而另一個進程在事件发生後將其喚醒。睡眠和喚醒通常被稱為序列協調或條件同步機制。

為了說明這一點，讓我們考慮一種叫做semaphore[4]的同步機制，它可以協調生產者和消費者。一個旗語體維護一個計數，並提供兩個操作。"V "操作（針對生產者）遞增計數。P "操作（針對消費者）等待，直到計數非零，然後遞減並返回。如果只有一個生產者線程和一個消費者線程，而且它們在不同的CPU上執行，編譯器也沒有太過激進的優化，那麽這個實現是正確的。

```cpp
100 struct semaphore {
101 struct spinlock lock;
102   int count;
103 };
104
105 void
106 V(struct semaphore *s)
107 {
108   acquire(&s->lock);
109   s->count += 1;
110   release(&s->lock);
111 }
112
113 void
114 P(struct semaphore *s)
115 {
116   while(s->count == 0)
117   ;
118   acquire(&s->lock);
119   s->count -= 1;
120   release(&s->lock);
121 }
```

上面的實現是昂貴的。如果生產者很少行動，消費者就會花大部分時間在while循環中旋轉，希望得到一個非零的計數。消費者的CPU可以通過反覆輪詢s->count來找到比忙等更有成效的工作。避免忙碌的等待需要有一種方法讓消費者讓出CPU，並在V增量計數後才繼續工作。

這里是朝這個方向邁出的一步，不過我們會看到，這還不夠。讓我們想象一對調用，睡眠和喚醒，其工作原理如下。Sleep(chan)對任意值chan進行睡眠，稱為等待通道。Sleep使調用進程進入睡眠狀態，釋放CPU進行其他工作。Wakeup(chan)喚醒所有在chan上睡覺的進程（如果有的話），使它們的睡眠調用返回。如果沒有進程在chan上等待，則wakeup不做任何事情。我們可以更改旗語實現，使用sleep和wakeup（黃色高亮顯示的更改）。

```cpp
200 void
201 V(struct semaphore *s)
202 {
203   acquire(&s->lock);
204   s->count += 1;
205   wakeup(s);
206   release(&s->lock);
207 }
208
209 void
210 P(struct semaphore *s)
211 {
212   while(s->count == 0)
213     sleep(s);
214   acquire(&s->lock);
215   s->count -= 1;
216   release(&s->lock);
217 }
```

P現在放棄了CPU而不是旋轉，這很好。然而，事實證明，用這個接口設計睡眠和喚醒並不直接，而不會遭受所謂的丟失喚醒問題。假設P在第212行发現s->count == 0。當P在第212行和213行之間時，V在另一個CPU上運行：它將s->count改為非零，並調用wakeup，wakeup发現沒有進程在睡覺，因此什麽也不做。現在P在第213行繼續執行：它調用sleep並進入睡眠狀態。這就造成了一個問題：P正在睡覺，等待一個已經发生的V調用。除非我們運氣好，生產者再次調用V，否則消費者將永遠等待，即使計數是非零。

這個問題的根源在於，P只有在s->count ==0時才會睡眠的不變性被V在恰好錯誤的時刻運行所違反。保護這個不變性的一個不正確的方法是移動P中的鎖的獲取（在下面的黃色中高亮顯示），使其對計數的檢查和對睡眠的調用是原子的。

```cpp
300 void
301 V(struct semaphore *s)
302 {
303   acquire(&s->lock);
304   s->count += 1;
305   wakeup(s);
306   release(&s->lock);
307 }
308
309 void
310 P(struct semaphore *s)
311 {
312   acquire(&s->lock);
313   while(s->count == 0)
314     sleep(s);
315   s->count -= 1;
316   release(&s->lock);
317 }
```

人們可能希望這個版本的P能夠避免丟失的喚醒，因為鎖會阻止V在第313和314行之間執行。它做到了這一點，但它也會死鎖。P在睡眠時保持著鎖, 所以V將永遠阻塞在等待鎖的過程中.

我們將通過改變sleep的接口來解決前面的方案：調用者必須將條件鎖傳遞給sleep，這樣它就可以在調用進程被標記為睡眠並在睡眠通道上等待後釋放鎖。這個鎖會強制並发的V等到P完成讓自己進入睡眠狀態，這樣喚醒就會发現睡眠中的消費者，並將其喚醒。一旦消費者再次被喚醒，睡眠就會重新獲得鎖，然後再返回。我們新的正確的睡眠/喚醒方案可用如下（變化用黃色突出顯示）。

```cpp
400 void
401 V(struct semaphore *s)
402 {
403   acquire(&s->lock);
404   s->count += 1;
405   wakeup(s);
406   release(&s->lock);
407 }
408
409 void
410 P(struct semaphore *s)
411 {
412   acquire(&s->lock);
413   while(s->count == 0)
414     sleep(s, &s->lock);
415   s->count -= 1;
416   release(&s->lock);
417 }
```

P持有s->鎖的事實阻止了V在P檢查c->count和調用睡眠之間試圖喚醒它。但是，請注意，我們需要睡眠來原子地釋放s->鎖並使消耗進程進入睡眠狀態。

## 7.6 Code: Sleep and wakeup

讓我們看看sleep (kernel/proc.c:548) 和 wakeup (kernel/proc.c:582) 的實現。其基本思想是讓sleep將當前進程標記為SLEEPING，然後調用sched釋放CPU；wakeup尋找一個在給定的等待通道上睡覺的進程，並將其標記為RUNNABLE。sleep和wakeup的調用者可以使用任何相互方便的數字作為通道。Xv6經常使用參與等待的內核數據結構的地址。

Sleep獲取p->lock（kernel/proc.c:559）。現在進入睡眠的進程同時持有p->lock和lk。在調用者（在本例中，P）中，持有lk是必要的：它保證了沒有其他進程（在本例中，運行V的進程）可以啟動對wakeup(chan)的調用。現在，sleep持有p->鎖，釋放lk是安全的：其他進程可能會啟動對wakeup(chan)的調用，但wakeup會等待獲取p->鎖，因此會等到sleep完成將進程放入睡眠狀態，使wakeup不會錯過睡眠。

有一個小的複雜情況：如果lk和p->lock是同一個鎖，那麽sleep如果試圖獲取p->lock，就會和自己死鎖。但是如果調用sleep的進程已經持有p->lock，那麽為了避免錯過並发喚醒，它不需要再做任何事情。當wait (kernel/proc.c:582)調用sleep並持有p->lock時，就會出現這種情況。

現在sleep持有p->鎖，而沒有其他的鎖，它可以通過記錄睡眠通道，將進程狀態改為SLEEPING，並調用sched(kernel/proc.c:564-567)來使進程進入睡眠狀態。

一會兒就會明白為什麽在進程被標記為SLEEPING之後才釋放p->lock（由調度器）是至關重要的。

在某些時候，進程會獲取條件鎖，設置睡眠者正在等待的條件，並調用wakeup(chan)。重要的是，wakeup是在持有條件鎖1的情況下調用的。Wakeup循環瀏覽進程表（kernel/proc.c:582）。它獲取它所檢查的每一個進程的p->鎖，一方面是因為它可能會操縱該進程的狀態，另一方面是因為p->鎖確保睡眠和喚醒不會相互錯過。當wakeup发現一個進程處於狀態為SLEEPING並有一個匹配的chan時，它就會將該進程的狀態改為RUNNABLE。下一次調度器運行時，就會看到這個進程已經準備好運行了。

為什麽睡眠和喚醒的鎖定規則能保證睡眠進程不會錯過喚醒？睡眠進程從檢查條件之前的一點到標記為sleeping之後的一點，都持有條件鎖或自己的p->鎖或兩者都持有。調用喚醒的進程在喚醒的循環中持有這兩個鎖。因此，waker要麽在消耗線程檢查條件之前使條件為真；要麽waker的wakeup嚴格地在睡眠線程被標記為SLEEPING之後檢查它。那麽wakeup就會看到睡眠進程，並將其喚醒（除非有其他事情先將其喚醒）。

有時會出現多個進程在同一個通道上睡覺的情況；例如，有多個進程從管道中讀取數據。調用一次喚醒就會把它們全部喚醒。其中一個進程將首先運行，並獲得睡眠被調用的鎖，（在管道的情況下）讀取管道中等待的任何數據。其他進程會发現，盡管被喚醒了，但沒有數據可讀。從他們的角度來看，喚醒是 "虛假的"，他們必須再次睡眠。出於這個原因，sleep總是在一個檢查條件的循環里面被調用。

如果sleep/wakeup的兩個用法不小心選擇了同一個通道，也不會造成傷害：它們會看到虛假的喚醒，但如上所述的循環會容忍這個問題。sleep/wakeup的魅力很大程度上在於它既輕量級（不需要創建特殊的數據結構來充當睡眠通道），又提供了一層間接性（調用者不需要知道他們正在與哪個具體進程交互）。

## 7.7 Code: Pipes

一個使用睡眠和喚醒來同步生產者和消費者的更複雜的例子是xv6對管道的實現。我們在第1章看到了管道的接口：寫入管道一端的字節被複製到內核緩沖區，然後可以從管道的另一端讀取。

未來的章節將研究圍繞管道的文件描述符支持，但我們現在來看pipewrite和piperead的實現。

每個管道由一個結構體管道表示，它包含一個鎖和一個數據緩沖區。

字段nread和nwrite統計從緩沖區讀取和寫入的字節總數。緩沖區環繞：在buf[PIPESIZE-1]之後寫入的下一個字節是buf[0]。計數不環繞。這個約定使得實現可以區分滿緩沖區(nwrite ==nread+PIPESIZE)和空緩沖區(nwrite ==nread)，但這意味著對緩沖區的索引必須使用buf[nread % PIPESIZE]，而不是只使用buf[nread](對nwrite也是如此)。

假設對piperead和pipewrite的調用同時发生在兩個不同的CPU上。Pipewrite (kernel/pipe.c:77)首先獲取管道的鎖，它保護了計數、數據和相關的不變量。然後，Piperead (kernel/pipe.c:103) 也試圖獲取管子的鎖，但不能。它在acquisition(kernel/spinlock.c:22)中旋轉，等待鎖的到來。當piperead等待時，pipewrite會在被寫入的字節(addr[0...n-1])上循環，依次將每個字節添加到管道中(kernel/pipe.c:95)。在這個循環中，可能會发生緩沖區被填滿的情況(kernel/pipe.c:85)。在這種情況下，pipewrite調用wakeup來提醒所有睡眠中的讀者有數據在緩沖區中等待，然後在&pi->nwrite上睡眠，等待讀者從緩沖區中取出一些字節。Sleep釋放pi->lock作為將pipewrite的進程進入睡眠狀態的一部分。

現在pi->lock是可用的，piperead設法獲取它並進入它的關鍵部分：它发現pi->nread != pi->nwrite (kernel/pipe.c:110) (pipewrite進入睡眠狀態的原因是pi->nwrite == pi->nread+PIPESIZE (kernel/pipe.c:85))，所以它落到了for
循環，將數據從管道(kernel/pipe.c:117)中複製出來，並按複製的字節數增加nread。現在有這麽多字節可以用來寫，所以 piperead 在返回之前調用 wakeup (kernel/pipe.c:124) 來喚醒所有沈睡的寫入者。Wakeup发現一個在&pi->nwrite上睡覺的進程，這個進程正在運行pipewrite，但在緩沖區填滿時停止了。它將該進程標記為RUNNABLE。

管道代碼為讀取器和寫入器使用了單獨的睡眠通道（pi->nread和pi->nwrite）；這可能會使系統在萬一有很多讀取器和寫入器在等待同一個管道的情況下更加高效。管道代碼在循環內睡眠，檢查睡眠條件；如果有多個讀寫器，除了第一個被喚醒的進程外，其他進程都會看到條件仍然是假的，然後再次睡眠。

## 7.8 Code: Wait, exit, and kill

睡眠和喚醒可以用於許多種等待。第1章中介紹的一個有趣的例子是，孩子的退出和父母的等待之間的互動。在孩子死亡的時候，父母可能已經在等待中睡覺了，也可能在做別的事情；在後一種情況下，後續的等待調用必須觀察到孩子的死亡，也許是在它調用退出之後很久。xv6在wait觀察到孩子的死亡之前，記錄孩子死亡的方式是讓exit將調用者放入ZOMBIE狀態，在這個狀態下停留，直到父體的wait注意到它，將孩子的狀態改為UNUSED，複製孩子的退出狀態，並將孩子的進程ID返回給父體。如果父進程比子進程先退出，父進程就會把子進程交給init進程，而init進程則永久地調用wait；這樣每個子進程都有父進程來清理。主要的實現難點是父進程和子進程的wait和退出，以及退出和退出之間可能會出現競賽和死鎖。

Wait使用調用進程的p->鎖作為條件鎖，以避免喚醒丟失，它在啟動時獲取該鎖（kernel/proc.c:398）。然後它掃描進程表。如果它发現一個處於ZOMBIE狀態的子進程，它釋放這個子進程的資源和它的proc結構，將子進程的退出狀態複製到提供給wait的地址（如果它不是0），並返回子進程的ID。如果wait找到了子進程，但沒有一個退出，它就調用sleep等待其中一個子進程退出(kernel/proc.c:445)，然後再次掃描。這里，在sleep中釋放的條件鎖是等待進程的p->鎖，也就是上面提到的特殊情況。請注意，wait經常擁有兩個鎖；它在試圖獲取任何子鎖之前，先獲取自己的鎖；因此，xv6的所有鎖都必須遵守相同的鎖定順序（父鎖，然後是子鎖），以避免死鎖。

Wait會查看每個進程的np->parent來尋找它的子進程。它使用 np->parent 而不持有 np->lock，這違反了共享變量必須受鎖保護的通常規則。np有可能是當前進程的祖先，在這種情況下，獲取np->lock可能會導致死鎖，因為這違反了上面提到的順序。在這種情況下，在沒有鎖的情況下檢查np->parent似乎是安全的；一個進程的父字段只有它的父字段才會被改變，所以如果np->parent==p為真，除非當前進程改變它，否則該值就不能改變。

Exit (kernel/proc.c:333)記錄退出狀態，釋放一些資源，將任何子進程交給init進程，在父進程處於等待狀態時喚醒它，將調用者標記為僵屍，並永久放棄CPU。最後的順序有點棘手。退出的進程必須持有父進程的鎖，同時將其狀態設置為ZOMBIE並喚醒父進程，因為父進程的鎖是條件鎖，可以防止在等待中失去喚醒功能。子進程也必須持有它自己的p->鎖，否則父進程可能會看到它處於ZOMBIE狀態，並在它還在運行時釋放它。

鎖的獲取順序對於避免死鎖很重要：因為wait在子鎖之前獲取父鎖，所以exit必須使用同樣的順序。

exit調用了一個專門的喚醒函數wakeup1，這個函數只喚醒父函數，而且只在父函數在wait中睡覺的情況下才喚醒(kernel/proc.c:598)。子程序在將狀態設置為ZOMBIE之前喚醒父程序可能看起來不正確，但這是安全的：盡管wakeup1可能會導致父程序運行，但在wait中的循環不能檢查子程序，直到子程序的p->鎖被調度器釋放，所以wait在退出將狀態設置為ZOMBIE之後才能查看退出的進程(kernel/proc.c:386)。

exit允許一個進程自行終止，而kernel/proc.c:611則允許一個進程請求另一個進程終止。如果讓kill直接摧毀受害者進程，那就太複雜了，因為受害者可能正在另一個CPU上執行，也許正處於對內核數據結構進行敏感更新的過程中。因此，kill的作用很小：它只是設置受害者的p->killed，如果它在睡覺，則喚醒它。最終，受害者會進入或離開內核，這時如果p->killed被設置，usertrap中的代碼會調用exit。如果受害者在用戶空間運行，它將很快通過進行系統調用或因為定時器（或其他設備）中斷而進入內核。

如果受害者進程處於睡眠狀態，kill的喚醒會使受害者從睡眠中返回。這是潛在的危險，因為正在等待的條件可能不是真的。

然而，xv6對sleep的調用總是被包裹在一個while循環中，在sleep返回後重新測試條件。一些對sleep的調用也會在循環中測試p->killed，如果設置了p->killed，則放棄當前活動。只有當這種放棄是正確的時候才會這樣做。例如，管道讀寫代碼如果設置了killed標志就會返回；最終代碼會返回陷阱，陷阱會再次檢查標志並退出。

一些xv6睡眠循環沒有檢查p->killed，因為代碼處於一個多步驟的系統調用中間，應該是原子的。virtio驅動(kernel/virtio_disk.c:242)就是一個例子：它沒有檢查p->killed，因為磁盤操作可能是一組寫操作中的一個，而這些寫操作都是為了讓文件系統處於一個正確的狀態而需要的。一個在等待磁盤I/O時被殺死的進程不會退出，直到它完成當前的系統調用和usertrap看到被殺死的標志。

## 7.9 Real world

xv6 調度器實現了一個簡單的調度策略，它依次運行每個進程。這種策略被稱為round robin。真正的操作系統實現了更複雜的策略，例如，允許進程有優先級。這個想法是，一個可運行的高優先級進程將被調度器優先於一個可運行的低優先級進程。這些策略可能會很快變得複雜，因為經常有相互競爭的目標：例如，操作者可能還想保證公平性和高吞吐量。此外，複雜的策略可能會導致非預期的交互，如優先級倒置和車隊。當低優先級和高優先級進程共享一個鎖時，就會发生優先級倒置，當低優先級進程獲得鎖時，就會阻止高優先級進程的進展。當許多高優先級進程都在等待一個獲得共享鎖的低優先級進程時，就會形成一個長長的等待進程的車隊；一旦車隊形成，就會持續很長時間。為了避免這類問題，在複雜的調度器中需要額外的機制。

睡眠和喚醒是一種簡單有效的同步方法，但還有很多其他方法。所有這些方法的第一個挑戰是避免我們在本章開始時看到的 "丟失喚醒 "問題。最初的Unix內核的睡眠只是禁用了中斷，這已經足夠了，因為Unix運行在單CPU系統上。因為xv6運行在多處理器上，所以它給睡眠增加了一個顯式鎖。FreeBSD 的 msleep 采用了同樣的方法。Plan 9的sleep使用了一個回調函數，在進入睡眠之前，在持有調度鎖的情況下運行；該函數的作用是在最後一分鐘檢查睡眠情況，以避免丟失喚醒。Linux內核的睡眠使用一個顯式的進程隊列，稱為等待隊列，而不是等待通道；隊列有自己的內部鎖。

在喚醒時掃描整個進程列表，尋找有匹配的chan的進程，效率很低。一個更好的解決方案是用一個數據結構代替睡眠和喚醒中的chan，該結構上存放著睡眠的進程列表，比如Linux的等待隊列。Plan 9的sleep和wakeup將該結構稱為rendezvous point或Rendez。許多線程庫將同一個結構稱為條件變量；在這種情況下，睡眠和喚醒的操作被稱為等待和信號。所有這些機制都有相同的味道：睡眠條件在睡眠過程中被某種原子掉落的鎖保護。

喚醒的實現喚醒了所有在某個特定通道上等待的進程，可能很多進程都在等待這個特定通道。操作系統會調度所有這些進程，它們會競相檢查睡眠狀況。

以這種方式行事的進程有時被稱為雷霆萬鈞，最好避免這種情況。

大多數條件變量都有兩個喚醒的基元：信號（signal），喚醒一個進程；廣播（broadcast），喚醒所有等待的進程。

Semaphores通常用於同步。計數通常對應於類似於管道緩沖區中可用的字節數或一個進程擁有的僵屍子代數。使用一個顯式計數作為抽象的一部分，可以避免 "丟失喚醒 "的問題：有一個顯式的計數，說明已經发生的喚醒次數。這個計數也避免了虛假喚醒和雷鳴般的群組問題。

終止進程和清理進程在xv6中引入了很多複雜性。在大多數操作系統中，它甚至更加複雜，因為，例如，受害進程可能深陷在內核中睡覺，而解開它的堆棧需要很多仔細的編程。許多操作系統使用顯式的異常處理機制來解除堆棧，比如longjmp。

此外，還有其他一些事件可以導致睡眠進程被喚醒，即使它正在等待的事件還沒有发生。例如，當一個Unix進程處於睡眠狀態時，另一個進程可能會向它发送一個信號。在這種情況下，該進程將從中斷的系統調用中返回，值為-1，錯誤代碼設置為EINTR。應用程序可以檢查這些值，並決定該怎麽做。Xv6不支持信號，這種複雜性不會出現 Xv6對kill的支持並不完全令人滿意：有睡眠循環可能應該檢查p->killed。一個相關的問題是，即使對於檢查p->killed的睡眠循環，睡眠和kill之間也存在競賽；後者可能會設置p->killed，並試圖在受害者的循環檢查p->killed之後但在它調用睡眠之前喚醒受害者。如果发生這個問題，受害者不會注意到p->killed，直到它所等待的條件发生。這可能會晚很多（例如，當virtio驅動返回一個受害者正在等待的磁盤塊時），也可能永遠不會发生（例如，如果受害者正在等待來自控制台的輸入，但用戶沒有鍵入任何輸入）。

真正的操作系統會用一個顯式的空閑列表在恒定時間內找到空閑的proc結構，而不是在allocproc中進行線性時間搜索；xv6為了簡單起見，使用線性掃描。

## 7.10 Exercises

1- Sleep必須檢查lk != &p->lock以避免死鎖(kernel/proc.c:558-561)。假設特殊情況被消除了，將其替換為

```cpp
if(lk !!!= &p->lock){ ．
  acquire(&p->lock);
  release(lk);
}
```

與

```cpp
release(lk);
acquire(&p->lock);
```

這樣做會破壞睡眠。怎麽做？

2-大部分進程清理可以通過exit或wait來完成。事實證明，exit必須是關閉打開的文件。為什麽要這樣做呢？答案涉及到管道。

3- 在xv6中實現semaphores而不使用sleep和wakeup（但使用spin locks也可以）。在xv6中用semaphores替換睡眠和喚醒的用法。判斷結果。

4-修正上面提到的kill和sleep之間的競賽，使在受害者的sleep循環檢查p->killed之後但在它調用sleep之前发生的kill，導致受害者放棄當前的系統調用。

5- 設計一個計劃，使每個睡眠循環都檢查p->killed，這樣，例如，在virtio驅動中的進程如果被其他進程殺死，就可以從while循環中快速返回。

6-修改xv6，當從一個進程的內核線程切換到另一個進程時，只使用一個上下文切換，而不是通過調度器線程切換。屈服線程需要自己選擇下一個線程並調用swtch。面臨的挑戰將是如何防止多個內核意外執行同一個線程；如何正確地進行鎖定；如何避免死鎖。

7-修改xv6的調度器，當沒有進程可運行時，使用RISC-V的WFI（wait for interrupt）指令。盡量保證，在任何有可運行進程等待運行的時候，沒有核心在WFI中暫停。

8-鎖p->鎖保護了很多不變性，當看某段被p->鎖保護的xv6代碼時，可能很難弄清楚是執行了哪個不變性。設計一個計劃，把p->鎖拆成幾個鎖，更幹凈。
